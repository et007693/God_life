# 2024-08-29 (목)

## 한 일

- 로그인 프로세스 공부
  - JWT 개념 학습
  - OAuth 개념 학습

## 학습한 내용

# JWT

> JWT(Json Web Token)는 당사자 간의 정보에 디지털 서명을 하고, JSON 객체로 안전하게 전송하기 위한 개방형 표준이다.

- JWT는 주로 인가 혹은 인증 정보를 서버와 클라이언트 사이에서 안전하게 주고 받기 위해 사용한다.
- 사용자 인증 정보를 넣어서 토큰을 발급해주면 클라이언트가 **인증이 필요한 리소스에 접근할 때 토큰을 포함해서 요청을 전송**하고, 서버에서는 복잡한 인증 과정 없이 **토큰만으로 사용자를 인증 및 인가할 수 있다.**
- 디지털 서명을 할 때는 통신 당사자 간의 비밀키를 이용한 HMAC 혹은 RSA와 같은 공개키, 개인키 암호화 방식을 사용할 수 있으며 메세지 무결성을 확인할 수 있어 신뢰할 수 있다.

## JWT 구조

- JWT는 **Header, Payload, Signature**로 이루어져 있다. **각 부분은 JSON 형태로 이루어져 있으며, Base64Url로 인코딩 되어 표현**된다. 이렇게 나누어진 부분은 `.`으로 연결된다.
- 디지털 서명된 토큰의 경우 **변조로부터 보호되지만, 누구나 읽을 수 있기 때문에** 암호화 되지 않은 경우, JWT의 header나 payload에 중요한 정보를 넣어서는 안된다.

### Header

```json
{
   "alg": "HS256",
   "typ": JWT
}
```

- 헤더는 일반적으로 토큰의 유형(typ)과 서명 알고리즘(alg)으로 구성된다.
  - **typ** : 토큰의 유형에서는 JWT와 같은 토큰의 타입을 지정
  - **alg** : 서명 알고리즘에는 HMAC SHA-256 혹은 RSA를 사용

### Payload

```json
{
  "sub": "1234567890",
  "name": "John Doe",
  "admin": true
}
```

- Payload는 Claim을 포함하는데, **Claim이란 Entity 및 추가 데이터에 대한 설명**이다. 즉, **토큰에서 사용될 정보들의 조각**이다.
- Claim은 총 3가지로 이루어지며, JSON 형태(Key, Value)로 사용자 정보와 같은 여러 정보들을 넣을 수 있다.
  - **Registered claims**(등록된 클레임) : 토큰 정보를 표현하기 위해 미리 정해진 종류의 데이터로, key의 길이는 모두 3글자이다.
    - iss : 토큰 발행자
    - exp : 토큰 만료 시간
    - sub : 토큰 제목이며 unique한 값을 사용해야 한다.
    - aud : 토큰 대상자
  - **Public claims**(공개 클레임) : 사용자 정의 클레임으로, 공개용 정보를 위해 사용된다. 충돌을 방지하기 위해 충돌 방지 네임스페이스를 포함하는 URI로 정의해야 한다.
  - **Private claims**(비공개 클레임) : 서버와 클라이언트 사이에 임의로 지정한 정보를 저장하는 클레임이다.

### Signature

- 서명은 토큰을 인코딩하거나 유효성 검증을 할 때 사용되는 고유한 암호화 코드이다.
- 서명 부분을 생성하기 위해 **인코딩된 헤더와 페이로드가 필요**하며, 인코딩한 값을 **키를 이용해 헤더의 alg에 정의한 알고리즘으로 서명**한 후 이 값을 다시 **Base64Url**로 인코딩한다.

### HMAC SHA-256

- HMAC SHA-256 알고리즘을 사용하는 경우 통신 당사자 간의 비밀키를 이용하여 서명하기 때문에 도중에 변경되지 않았는지에 대한 **메세지 무결성**만을 확인할 수 있다.
- HMAC은 해시 함수에 넣을 때 **비밀키 + 메세지 본문**을 넣게 된다. 여기서 메세지 본문이란 header와 payload를 의미한다.

### RSA

- 반면에 RSA의 경우, 메세지 본문을 해시 함수를 통해 해시 값을 구하고, 이 해시 값을 개인키로 암호화하여 전달한다.
- RSA 방식은 혼자만 가지고 있는 개인키로 서명을 하기 때문에 메세지 무결성에 더해 송신자를 확인할 수 있다.

## JWT 검증 방법

- 서버는 클라이언트가 전달한 JWT를 디코딩하여 header, payload, signature 세 부분으로 분할하고, 유효한 토큰인지 검증을 진행한다.
- 이 때 header의 alg에 명시된 방식에 따라 다른 검증 방식을 사용한다.
  - **HMAC** : header와 payload를 자신이 가진 비밀키와 함께 해시 함수에 넣어 서명을 생성하고, 전달받아 분할한 **signature**와 비교한다.
  - RSA : 개인키로 암호화된 header + payload를 자신의 공개키로 복호화해서 검증한다.
- 인증이 완료된 후, 클라이언트가 **요청한 정보를 다시 payload에 담아 전달**한다.

💡 전달된 JWT를 분해할 수 있는 이유는 **JWT는 암호화 하는 것이 아닌 Base64Url로 인코딩하여 전달되기 때문**이다.

## Basic vs Bearer

- Http 통신에서는 보호된 서버 리소스에 접근하는 클라이언트의 인증 정보(Credentials)를 확인하게 되며, 아래와 같은 인증 헤더를 요청에 사용한다.

> **Authorization : <type> <credentials>**

- 올바른 인증 정보를 넣으면 HTTP 상태 코드 `200 OK`, 인증 헤더를 누락하면 `401 Unauthorized`, 인증 정보를 넣었지만 접근 권한이 없다면 `403 Forbidden`이 반환된다.
- 이러한 인증 정보는 인증 방식을 나타내는 type에 따라 달라지게 되는데 **Basic**과 **Bearer**이 있다.

### Basic

- Basic은 가장 기본적인 인증 방식으로 사용자 ID와 PW를 Base64Url로 인코딩한 값을 인증 정보(Credentials)로 사용하는 방식이다.
- 즉 Authorization에 ID와 PW를 담는 것인데, 이렇게 되면 매 요청마다 ID, PW를 달고 요청하게 되고, 클라이언트와 서버가 요청을 보낼 때마다 사용자 정보를 함께 전달할 필요가 없게 된다.
- Basic 인증 방식은 간단하지만 몇 가지 단점 이 존재한다
  - 서버에 사용자 목록을 저장하게 되는데 요청한 리소스가 많거나 사용자가 많으면 목록에서 권한을 확인하는 시간이 길어지게 된다.
  - **ID, PW가 인코딩 되었을 뿐 암호화 되지 않기 때문에 Basic 토큰 값이 노출되면 ID, PW가 그대로 노출**되는 것이기 때문에 보안에 취약하다.
  - ID, PW 노출을 막기 위해 사용할 수 있는 것이 **https**이기 때문에 Basic 인증을 사용하는 요청은 반드시 Http, SSL/TLS로 통신해야 한다.

### Bearer

- Bearer 방식은 OAuth 2.0 프레임워크에서 사용하는 토큰 인증 방식이다. 즉, 토큰을 인증 정보로 사용한다는 의미이다.
- Bearer 토큰의 형태는 인증 서버에 따라 다르지만 16진수의 문자열을 사용하기도 하고 JWT를 사용하기도 한다. 중요한 건 Bearer 토큰은 클라이언트가 해석할 수 없는 형태여야 하고, 사용자의 정보를 전달하면 안된다.
- Bearer 토큰은 쉽게 복호화 할 수 없고 OAuth 프레임워크의 인증 및 리소스 서버는 SSL/TLS를 필수로 사용하기 때문에 Basic에 비해 안전하다.
- 만약 토큰이 외부로 노출되면 다른 서비스도 토큰으로 바로 리소스에 접근할 수 있지만 서버에서 토큰의 리소스 접근 권한을 쉽게 철회할 수 있으며, ID와 PW가 노출되는 것이 아니기 때문에 Basic에 비해 노출되어도 훨씬 피해가 적다.

## Access Token, Refresh Token

### Access Token의 단점

- JWT는 Stateless 하기 때문에 서버는 토큰을 가진 클라이언트가 진짜 본인이 맞는지 알 수 없다.
- 이를 해결하기 위해 Access Token의 유효 기간을 짧게 설정한다면 로그인을 자주 해야 하기 때문에 불편하다.
- 반대로 유효 기간을 길게 할 경우, 서버는 한 번 발급한 토큰에 대한 제어권이 없기 때문에 보안상 문제가 발생한다.

### Refresh Token의 등장

- 위와 같은 문제를 해결하기 위해 **Refresh Token**이 등장했다.
- Access Token의 보안을 강화하기 위해 토큰의 유효 시간을 짧게 설정하여 자주 재발급하되, 사용자가 자주 로그인해야 하는 불편함을 없애기 위해 사용한다. 즉, **클라이언트가 가진 Access Token이 만료되었을 때 Access Token을 새로 발급받기 위해 사용**한다.

### Access Token 재발급 과정

### JWT 형태의 Refresh Token

- JWT 형태의 Refresh Token이라면 JWT의 특징처럼 statleless하고, 토큰 자체에 데이터를 담을 수 있다.
- **Refresh Token의 유효성을 검증하기 위해 DB에 접근하지 않아도 된다.**
- Refresh Token을 서버에서 제어할 수 없기 때문에 Refresh Token을 탈취 당한다면, **토큰을 무효화 시킬 수 있는 방법이 없어** 유효 시간이 만료될 때까지 기다려야 한다.

### String 형태의 Refresh Token

- Refresh Token으로 random String이나 UUID를 사용한다면, 해당 토큰을 사용자와 매핑되도록 DB에 저장해야 한다.
- 유효성 검증을 위해 DB에 접근해야 한다.
- DB에 저장되어 있기 때문에 탈취 당했을 때 사용자를 강제로 로그아웃 시키거나 무효화 시킬 수 있다.

# Oauth

> Oauth란 인터넷 사용자들이 비밀번호를 제공하지 않고 다른 웹사이트 상의 자신들의 정보에 대해 웹사이트나 애플리케이션의 접근 권한을 부여할 수 있는 공통적인 수단으로서 사용되는, 접근 위임을 위한 개방형 표준이다.

- 사용자들이 애플리케이션에 비밀번호를 제공하지 않고, 카카오나 구글 같은 곳에 저장된 **자신들의 정보에 접근할 수 있는 권한을 부여**할 수 있는 방법이다.
- 외부 소셜 계정을 이용하여 회원가입이나 로그인을 간편하게 할 수 있으며, **애플리케이션이 사용자의 접근 권한을 위임 받음으로써** 연동된 계정의 작업을 수행할 수 있다.

## 구성요소

### Resource Owner

- 리소스 소유자(일반적인 사용자)
- 카카오나 구글에 있는 자신의 계정 일부에 대한 엑세스 권한을 애플리케이션(우리의 서비스)에 부여한다.

### Client

- 사용자가 아니라 카카오나 구글의 자원을 사용하기 위해 접근을 요청하는 서비스 혹은 애플리케이션을 의미(우리가 개발하려는 서비스)

### Authorization Server

- 리소스 소유자를 인증하고, Client에게 권한을 부여하는 서버
- 리소스 소유자는 Authorization Server에 ID, PW를 넘겨 **Authorization Code**를 발급받고, 이를 Client에게 넘겨 Client가 Token을 발급받을 수 있도록 한다.

### Resource Server

- 카카오나 구글처럼 리소스를 가진 서버
- 사용자의 정보에 접근하는 데 사용되는 api 서비스를 제공한다.
- Access Token을 발급받은 Client의 요청을 수락하고 요청에 대한 응답을 해준다.

## 권한 요청 시 필요한 파라미터

- Oauth를 사용하려면 Client를 Resource Server에 등록해야 한다. 이 때 Client는 Redirect URI를 등록해야 하며, Client ID를 발급받게 되며, 선택적으로 Client Secret을 발급받게 된다.
- 그 후 Client가 Authorization Server에 인증 요청을 할 때 Redirect URI, Client ID, Response Type, Scope 등을 넘겨주며, Access Token을 요청할 때는 Grant Type을 넘겨준다.

### Redirect URI

- 사용자가 애플리케이션을 인증한 후 OAuth 2.0 서비스가 사용자에게 반환되는 위치
- 공격자가 인증 코드나 엑세스 토큰을 가로챌 수 있는 리다이렉션 공격을 방지하기 위해 이전에 서비스에 등록된 URL로만 사용자를 리다이렉션한다.

### Client ID, Client Secret

- Client ID는 애플리케이션을 식별하는 식별자 ID를 의미하며, Client가 Authorization Server에 등록하면 발급받을 수 있다.
- Resource Server 입장에서는 다양한 서비스가 존재하기 때문에 요청하는 Client가 어떤 Client인지 구별하기 위해 사용된다.
- Client Secret는 Client ID에 대한 비밀번호이다.

### Response Type

- Client가 Authorization Server로 권한 부여 동의 요청 시 포함되는 값으로, 권한 부여 방식에 따라 전달하는 값이 다르다.
  - Authorization Code Grant 방식 : `response_type = code`
  - Implicit Grant 방식 : `response_type = token`

### Scope

- Client 권한을 설정하기 위한 기능인데 Scope를 통해서 유저 리소스에 대한 Client의 접근 범위를 제한할 수 있다.
- 우리의 서비스(Client)가 사용자의 구글 연락처를 받아오고 싶다면, OAuth Scope에 연락처 Scope 문자열을 포함하여 OAuth 제공자에게 전달하면 된다. 만약 여러 개의 권한을 요청한다면 콤마를 통해 요청할 수 있다.
- 그 후 사용자는 Scope에 명시된 권한을 요청하는 화면을 만나게 되고, 이러한 과정을 거쳐 발급된 Access Token은 부여된 Scope에 해당하는 권한을 획득하게 된다.

### State

- CSRF 공격에 대비하기 위해 클라이언트가 권한 서버에 요청 시 포함하는 임의의 문자열
- 필수 사항은 아니지만 클라이언트가 요청 시 state를 포함시켰다면 권한 서버는 동일한 값을 클라이언트에게 보내야 한다.

### Grant Type

- Client가 Authorization Server로 Access Token 요청 시 포함되는 값이며, 권한 부여 방식에 따라 전달하는 값이 다르다.
  - Authorization Code Grant 방식 : `grant_type = authorization_code`
  - Resource Owner Password Credentials Grant 방식 : `grant_type = password`
  - Client Credentials Grand 방식 : `grant_type = client_credentials`

## 인증 종류 및 동작 과정

- OAuth 2.0 에서는 Authorization Server가 Client에게 **토큰을 부여하는 방식(권한을 부여하는 방식)**에 따른 프로토콜을 4가지 종류로 구분하여 제공하고 있다.
- **Authorization Code Grant와 Implicit Grant는 인증 과정에 사용자가 개입**하며, 나머지 두 방식은 사용자가 개입하지 않는다.

### Authorization Code Grant

- 권한 부여 승인 코드 방식이라고 하며, 토큰을 발급받기 위해 Authorization Server가 생성해서 resource owner에게 전달한 Authorization Code를 전달하는 방법이다.
- 간편 로그인 기능에서 사용되는 방식으로 클라이언트가 사용자를 대신하여 특정 자원에 접근을 요청할 때 사용되는 방식이다.

### Implicit Grant

- 암묵적 승인 방식이라고 하며, OAuth 2.0에서 가장 많이 사용된다
- 위에서 알아본 권한 부여 코드의 발급 없이 바로 Access Token을 발급한다. 따라서 보안 상의 문제로 인해 만료 기간을 짧게 설정해야 한다는 특징을 가지고 있다.

### Resource Owner Password Crendentials Grant

- 자원 소유자 자격 증명 승인 방식으로 username과 password로 Access Token을 발급받는 방식이다.
- 권한 서버, 리소스 서버, 클라이언트가 모두 같은 시스템에 속해 있을 때만 사용할 수 있고, Client가 타 사의 외부 프로그램일 경우에는 이 방식을 적용하면 안된다.

### Client Credentials Grant

- 클라이언트 자격 증명 승인 방식으로, 리소스 소유자가 아닌 Client에 대한 인가가 필요할 떄 사용되는 방식이다.
- 자신이 관리하는 리소스 혹은 권한 서버에 해당 클라이언트를 위한 제한된 리소스 접근 권한이 설정되어 있는 경우에 사용된다.
