# 2024-08-28 (수)

## 한 일

- redis 학습 및 스프링 실습
- Spring Security 동작 과정 학습

## 학습한 내용

- redis는 인 메모리 기반의 key-value 형식의 저장소로, 주로 캐시 기능을 많이 사용한다.
- redis를 설치하고 Spring boot의 라이브러리를 통해 쉽게 사용할 수 있다.

# Oauth

> [https://velog.io/@hj\_/Spring-Security-인증-모듈-및-처리-과정#spring-security-모듈](https://velog.io/@hj_/Spring-Security-%EC%9D%B8%EC%A6%9D-%EB%AA%A8%EB%93%88-%EB%B0%8F-%EC%B2%98%EB%A6%AC-%EA%B3%BC%EC%A0%95#spring-security-%EB%AA%A8%EB%93%88)

# Spring Security

> Spring Security는 Spring 기반의 애플리케이션의 **보안(인증, 인가, 권한)**을 담당하는 **스프링 하위 프레임워크**이며 인증과 권환에 대한 부분을 Filter 흐름에 따라 처리한다.

## 인증과 인가

- 인증(Authentication) : 해당 사용자가 **본인이 맞는지를 확인**하는 절차
- 인가(Authorization) : **인증된 사용자**가 요청한 자원에 접근 가능한지를 결정하는 절차

💡 Spring Security는 인증 절차를 거친 후에 권한에 따른 인가 절차를 진행한다. 인가 과정에서 해당 리소스에 대한 접근 권한이 있는지 확인한다.

## Principal과 Credential

- Spring은 인증과 인가를 위해 **Principal을 아이디**로, **Credential을 비밀번호**를 사용하는 Credential 기반의 인증 방식을 사용한다.
  - Principal(접근 주체) : 보호받는 Resource에 접근하는 대상
  - Credential(비밀번호) : Resource에 접근하는 대상의 비밀번호
- 인증이 완료되면 최종적으로 Spring Security에 사용자의 정보가 담긴 `UsernamePasswordAuthenticationToken`을 전달하게 되는데 이 클래스의 최상위 인터페이스가 바로 `Principal`이다.
- `Principal`을 상속받은 것이 `Authentication` 인터페이스이며 `Principal`과 `Credential`을 가져오는 메서드가 있다.

## Filter와 Interceptor

> **HTTP 요청 → WAS → 필터 → 서블릿(`DispatcherServlet`) → Controller**

- `Filter`는 `DispatcherServlet`으로 가기 전에 호출되며, 필터가 적절하지 못한 요청이라고 판단하면 서블릿을 호출하지 않는다.
  - 로그인하지 않은 사용자의 요청이라면 서블릿을 호출하지 않음

> **HTTP 요청 → WAS → 필터 → 서블릿(`DispatcherServlet`) → 스프링 인터셉터 → Controller**

- `Intercepter`는 `Filter`와는 다르게 서블릿이 호출된 다음에 호출된다. `Intercepter`는 Spring이 제공하는 기술이고, 스프링 MVC의 시작점이 `DispatcherServlet`이기 때문에 서블릿이 뒤에서 호출되는 것이다.

# Spring Security 로그인 프로세스

## 인증 전 단계

1. **AntPathRequestMatcher(/login)**

- 사용자가 요청한 요청 정보를 확인하여 요청 정보 url이 `/login` 으로 시작하는지 확인한다.요청 url이 `/login`으로 시작하고 요청방식이 POST라면 인증의 다음 단계를 진행하고 그렇지 않으면 다음 `filter`로 진행한다.
- /login이라는 url은 default 값이며, Spring Security의 웹 보안 기능을 설정하기 위해 `WebSecurityConfigurerAdapter`를 상속받아 구현한 설정 클래스에서 변경 가능하다.
  - `configure()` 메서드 내부에서 `.loginProcessingUrl()` 으로 변경할 수 있다.

2. **Authentication**

- 실제 인증 처리는 `Authentication`을 이용해서 하게 되는데, 로그인 페이지에서 입력한 `Username`과 `Password`를 인증 객체(`Authentication`)에 저장해서 인증을 처리하는 `AuthenticationManager`에게 맡기게 된다.
  - `Authentication`은 인터페이스이기 때문에 구현체인 `UsernamePasswordAuthenticationToken`에 저장되어 `AuthenticationManager`에게 전달되게 된다.

## 인증 후 단계

3. **AuthenticationProvider**

- `AuthenticationManager`는 내부적으로 `AuthenticationProvider`에게 인증 처리를 위임하게 된다.
  - `Provider`가 인증 처리를 담당하는 클래스로, 인증 성공과 실패에 따라 동작을 다르게 수행한다.
- 인증에 성공하면 `Authentication`객체를 생성하여 `User`객체와 `Authorities`(유저 권한 정보) 객체를 담아서 `AuthenticationManager`에게 반환한다.
- 인증에 실패하면 `AuthenticationException`예외를 반환하여 `UsernamePasswordAuthenticationFilter`로 돌아가서 예외 처리를 수행한다.

4. AuthenticationManager

- `AuthenticationManager`는 `Provider`로부터 반환받은 `Authentication`(`User`+ `Authorities`)를 `SecurityContext`에 저장한다.
- `SecurityContext`는 `Session`에도 저장되어 전역적으로 `SecurityContext`를 참조할 수 있으며, 인증 성공 이후에는 `SuccessHandler`에서 인증 성공 이후의 로직을 수행하게 된다.

💡 Spring Security 내부 상세 과정은 참고 블로그를 보자
